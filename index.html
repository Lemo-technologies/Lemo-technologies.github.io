<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>LEMO-TUTOR Â· ENTHUSIAST CORE</title>
    <!-- Google fonts & KaTeX for beautiful math -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false}]});"></script>
    <style>
        :root { --accent: #00ff88; --bg: #05070a; --glass: rgba(15, 20, 25, 0.95); --border: rgba(255, 255, 255, 0.1); --text: #f0f2f5; --cursor-color: #00ffaa; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: var(--bg); color: var(--text); font-family: 'Inter', sans-serif; overflow: hidden; }
        .app-shell { display: flex; flex-direction: column; height: 100dvh; width: 100%; max-width: 1000px; margin: 0 auto; border-left: 1px solid var(--border); border-right: 1px solid var(--border); }
        header { padding: 1.2rem 1.5rem; background: rgba(5,7,10,0.9); backdrop-filter: blur(20px); border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; z-index: 100; }
        .logo { font-size: 1rem; font-weight: 700; letter-spacing: 4px; color: var(--accent); text-transform: uppercase; }
        .glow-dot { width: 8px; height: 8px; background: var(--accent); border-radius: 50%; box-shadow: 0 0 12px var(--accent); display: inline-block; margin-right: 10px; }
        #chat-container { flex: 1; overflow-y: auto; padding: 25px; display: flex; flex-direction: column; gap: 20px; scroll-behavior: smooth; }
        .message { max-width: 85%; padding: 16px 20px; border-radius: 18px; line-height: 1.6; font-size: 0.95rem; animation: pop 0.25s ease; position: relative; }
        .user-msg { align-self: flex-end; background: linear-gradient(135deg, rgba(0,255,136,0.1) 0%, rgba(0,255,136,0.02) 100%); border: 1px solid rgba(0, 255, 136, 0.4); border-bottom-right-radius: 4px; color: var(--accent); }
        .ai-msg { align-self: flex-start; background: var(--glass); border: 1px solid var(--border); border-bottom-left-radius: 4px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
        .input-area-wrapper { padding: 20px; background: linear-gradient(to top, var(--bg) 80%, transparent); }
        .input-card { background: #12171d; border: 1px solid var(--border); border-radius: 20px; padding: 8px 15px; display: flex; align-items: center; gap: 12px; }
        input[type="text"] { flex: 1; background: transparent; border: none; color: white; padding: 12px; font-size: 16px; outline: none; }
        .send-btn { background: var(--accent); color: #000; border: none; width: 45px; height: 45px; border-radius: 15px; font-weight: 900; cursor: pointer; }
        #preview-box { display: none; padding: 10px; text-align: left; }
        #preview-box img { height: 60px; border-radius: 8px; border: 1px solid var(--accent); }
        #lock-screen { position: fixed; inset: 0; background: #000; z-index: 10000; display: flex; align-items: center; justify-content: center; }
        .lock-card { width: 85%; max-width: 350px; padding: 40px; background: #0a0a0a; border: 1px solid var(--accent); border-radius: 30px; text-align: center; }
        pre { background: #000; padding: 12px; border-radius: 8px; overflow-x: auto; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; border: 1px solid #222; margin: 10px 0; }
        /* cursor / pen dot effect */
        .typing-cursor {
            display: inline-block;
            width: 6px;
            height: 1.2em;
            background-color: var(--cursor-color);
            margin-left: 4px;
            border-radius: 2px;
            vertical-align: middle;
            box-shadow: 0 0 8px var(--cursor-color);
            animation: blink 1s infinite;
        }
        @keyframes blink { 0%,100%{ opacity:1; } 50%{ opacity:0.2; } }
        .message.ai-msg .math-rendered { opacity: 1; transition: opacity 0.3s; }
        .raw-typing { word-break: break-word; }
    </style>
</head>
<body>

<div id="lock-screen">
    <div class="lock-card">
        <h2 style="color:var(--accent); letter-spacing: 5px;">CORE LOCKED</h2>
        <input type="password" id="passKey" placeholder="Enter gsk_ key..." style="width:100%; padding:15px; background:#111; border:1px solid #333; color:white; border-radius:12px; margin: 20px 0; box-sizing:border-box;">
        <button onclick="unlock()" style="width:100%; padding:15px; background:var(--accent); border:none; font-weight:800; border-radius:12px; cursor:pointer;">INITIALIZE</button>
    </div>
</div>

<div class="app-shell">
    <header><div class="logo"><span class="glow-dot"></span>LEMO-TUTOR 3.4</div></header>
    <div id="chat-container">
        <!-- initial message will be injected dynamically with random greeting -->
    </div>
    <div class="input-area-wrapper">
        <div id="preview-box"></div>
        <div class="input-card">
            <button style="background:transparent; border:none; color:var(--accent); font-size:1.5rem; cursor:pointer;" onclick="document.getElementById('imgInp').click()">ðŸ“Ž</button>
            <input type="file" id="imgInp" accept="image/*" style="display:none" onchange="handleImg()">
            <input type="text" id="userInp" placeholder="Type or upload..." onkeypress="if(event.key==='Enter') execute()">
            <button class="send-btn" onclick="execute()">â†’</button>
        </div>
    </div>
</div>

<script>
    (function() {
        // --------------------  CONFIG / GREETINGS  --------------------
        const greetings = [
            "Hello Enthusiast! Memory systems online. Ready to explore engineering depths?",
            "Greetings, curious mind! Lemo-Tutor at your service. How shall we build today?",
            "Hey there, engineering enthusiast! Persistent memory active. What's on your workbench?",
            "Ah, an enthusiast! I've been expecting you. All systems recall ready.",
            "Welcome back, tinkerer! Conversation memory locked and loaded. What shall we solve?",
            "Hi! Lemo-Tutor online. I remember everything we discuss. Shoot your question, enthusiast!"
        ];

        // pick a random greeting for the initial message
        function randomGreeting() {
            return greetings[Math.floor(Math.random() * greetings.length)];
        }

        // update system prompt to address user as enthusiast (no 'Director')
        const baseSystemPrompt = "You are Lemo-Tutor, a world-class Engineering authority. You remember everything the user says. The user is an engineering enthusiast â€” always address them as 'enthusiast' or a similarly warm, informal term (never 'Director'). Vary your greetings and responses naturally. Be concise but profound. Use LaTeX for math ($$, $).";

        // --------------------  GLOBAL STATE  --------------------
        let ACTIVE_KEY = localStorage.getItem('L_KEY');
        let imgBase64 = null;
        let chatHistory = [
            { role: "system", content: baseSystemPrompt }
        ];

        // DOM elements
        const lockScreen = document.getElementById('lock-screen');
        const chatContainer = document.getElementById('chat-container');
        const userInp = document.getElementById('userInp');
        const previewBox = document.getElementById('preview-box');
        const imgInp = document.getElementById('imgInp');

        // initial unlock check
        if(ACTIVE_KEY) {
            lockScreen.style.display = 'none';
            // inject random greeting message
            addInitialGreeting();
        }

        function addInitialGreeting() {
            const greeting = randomGreeting();
            // add to chat container and history
            const msgDiv = document.createElement('div');
            msgDiv.className = 'message ai-msg';
            msgDiv.innerHTML = greeting;
            chatContainer.appendChild(msgDiv);
            chatHistory.push({ role: "assistant", content: greeting });
        }

        // --------------------  LOCK / UNLOCK  --------------------
        window.unlock = function() {
            const k = document.getElementById('passKey').value.trim();
            if(k.startsWith('gsk_')) { 
                localStorage.setItem('L_KEY', k); 
                location.reload(); 
            } else alert("INVALID KEY");
        };

        // --------------------  IMAGE HANDLING (unchanged)  --------------------
        window.handleImg = function() {
            const file = imgInp.files[0];
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const MAX_WIDTH = 700; 
                    let width = img.width; let height = img.height;
                    if (width > MAX_WIDTH) { height *= MAX_WIDTH / width; width = MAX_WIDTH; }
                    canvas.width = width; canvas.height = height;
                    canvas.getContext('2d').drawImage(img, 0, 0, width, height);
                    imgBase64 = canvas.toDataURL('image/jpeg', 0.6);
                    previewBox.innerHTML = `<img src="${imgBase64}">`;
                    previewBox.style.display = 'block';
                };
                img.src = e.target.result;
            };
            if(file) reader.readAsDataURL(file);
        };

        // --------------------  TYPING ANIMATION & RENDERING  --------------------
        function typewriterEffect(containerElement, fullText, speed = 25) {
            return new Promise((resolve) => {
                // clear container and prepare raw span + cursor
                containerElement.innerHTML = ''; 
                const rawSpan = document.createElement('span');
                rawSpan.className = 'raw-typing';
                const cursorSpan = document.createElement('span');
                cursorSpan.className = 'typing-cursor';
                containerElement.appendChild(rawSpan);
                containerElement.appendChild(cursorSpan);

                let index = 0;
                function type() {
                    if (index < fullText.length) {
                        rawSpan.textContent += fullText.charAt(index);
                        index++;
                        setTimeout(type, speed);
                    } else {
                        // typing finished: remove cursor and transform to pretty formatted + math
                        cursorSpan.remove();
                        // now upgrade the raw text to rendered markdown & math
                        const rawText = rawSpan.textContent; // full plain text
                        // use parse to get basic markdown (bold, code, line breaks)
                        const withMarkdown = parse(rawText);  // this adds <pre>, <strong>, <br>
                        // create a temporary div to hold formatted html, then render math inside it
                        const formattedDiv = document.createElement('div');
                        formattedDiv.className = 'math-rendered';
                        formattedDiv.innerHTML = withMarkdown;
                        // replace content
                        containerElement.innerHTML = ''; 
                        containerElement.appendChild(formattedDiv);
                        // apply KaTeX auto-render to this new div
                        if (window.renderMathInElement) {
                            renderMathInElement(formattedDiv, {
                                delimiters: [
                                    {left: '$$', right: '$$', display: true},
                                    {left: '$', right: '$', display: false}
                                ],
                                throwOnError: false
                            });
                        } else {
                            // fallback: KaTeX not loaded yet, but it's async; we can wait a bit
                            setTimeout(() => {
                                if (window.renderMathInElement) {
                                    renderMathInElement(formattedDiv, {delimiters: [
                                        {left: '$$', right: '$$', display: true},
                                        {left: '$', right: '$', display: false}
                                    ], throwOnError: false});
                                }
                            }, 100);
                        }
                        resolve();
                    }
                }
                type();
            });
        }

        // original parse function (enhanced a bit)
        function parse(text) {
            return text.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
                       .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                       .replace(/\n/g, '<br>');
        }

        // --------------------  ADD MESSAGE (with typing for AI)  --------------------
        function addMessage(content, sender, useTyping = false) {
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${sender === 'user' ? 'user-msg' : 'ai-msg'}`;
            msgDiv.id = 'm-' + Date.now() + Math.random();
            
            if (sender === 'user' || !useTyping) {
                // user message or non-typing (like loading) goes directly
                msgDiv.innerHTML = content;
                chatContainer.appendChild(msgDiv);
            } else {
                // AI message with typing effect
                chatContainer.appendChild(msgDiv);
                // start typing animation, after that we resolve
                typewriterEffect(msgDiv, content, 30); // speed 30ms per char (slow but fluid)
            }
            chatContainer.scrollTop = chatContainer.scrollHeight;
            return msgDiv.id;
        }

        // legacy addMsg (for loading, etc) but we will mostly use addMessage
        function addMsg(h, c) {
            if (c.includes('ai-msg') && h !== '<span style="opacity:0.5; letter-spacing:2px;">RECALLING...</span>') {
                // we want typing only for actual AI responses, not for "RECALLING..."
                return addMessage(h, 'ai', true);
            } else {
                const d = document.createElement('div'); 
                d.className = `message ${c}`; 
                d.innerHTML = h; 
                d.id = 'm-' + Date.now();
                chatContainer.appendChild(d);
                chatContainer.scrollTop = chatContainer.scrollHeight; 
                return d.id;
            }
        }

        // --------------------  EXECUTE (main interaction)  --------------------
        window.execute = async function() {
            const query = userInp.value.trim();
            if(!query && !imgBase64) return;

            // user message display
            addMessage(query || "Analyzing visual data...", 'user');
            userInp.value = '';
            previewBox.style.display = 'none';
            const loadId = addMsg('<span style="opacity:0.5; letter-spacing:2px;">RECALLING...</span>', 'ai-msg');

            // build user content for history
            let currentMessageContent;
            if (imgBase64) {
                currentMessageContent = [
                    { type: "text", text: query || "Analyze this image." },
                    { type: "image_url", image_url: { url: imgBase64 } }
                ];
            } else {
                currentMessageContent = query;
            }
            chatHistory.push({ role: "user", content: currentMessageContent });

            try {
                const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                    method: 'POST',
                    headers: { 
                        'Authorization': `Bearer ${localStorage.getItem('L_KEY')}`, 
                        'Content-Type': 'application/json' 
                    },
                    body: JSON.stringify({ 
                        model: "meta-llama/llama-4-scout-17b-16e-instruct", 
                        messages: chatHistory, 
                        temperature: 0.6  // slightly higher for varied greetings
                    })
                });

                const data = await response.json();
                // remove loading message
                document.getElementById(loadId)?.remove();
                imgBase64 = null;

                if(data.choices) {
                    const aiResponse = data.choices[0].message.content;
                    chatHistory.push({ role: "assistant", content: aiResponse });
                    // use typing animation for the response
                    addMessage(aiResponse, 'ai', true);
                } else {
                    addMessage("SYSTEM FAULT: Memory Overflow or Key Error.", 'ai', false);
                }
            } catch(e) {
                document.getElementById(loadId)?.remove();
                addMessage("OFFLINE. Check connection or key.", 'ai', false);
            }
        };

        // also need to keep original window.handleImg, unlock accessible; they are already.

        // ensure that any pre-existing static initial message is removed (none now)
        // but if user reloads with key, we already added initial via addInitialGreeting()
        // However if the key was present and we reload, the DOM may still have empty container
        // we call addInitialGreeting only if container empty
        window.addEventListener('load', function() {
            if(ACTIVE_KEY && chatContainer.children.length === 0) {
                addInitialGreeting();
            }
            // also re-run math rendering on any old messages if needed (but fresh load)
        });
    })();
</script>
</body>
</html>
