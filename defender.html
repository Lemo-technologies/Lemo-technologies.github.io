<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Silicon Defender | Daily Intellect Dose</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Playfair+Display:wght@700&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #0f0508;
            --gold: #d4af37;
            --rose: #ff1744;
            --blue: #00e5ff;
            --glass: rgba(255, 255, 255, 0.05);
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: #f3e5f5;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            touch-action: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* === DYNAMIC BACKGROUND === */
        body::before {
            content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;
            background: radial-gradient(circle at center, #1a0b10 0%, #000000 100%);
        }

        /* === UI ELEMENTS === */
        #ui-layer {
            position: absolute; top: 20px; left: 0; width: 100%;
            text-align: center; pointer-events: none; z-index: 10;
        }

        h1 {
            font-family: 'Playfair Display', serif; color: var(--gold); 
            font-size: 1.5rem; letter-spacing: 2px; margin: 0; text-transform: uppercase;
        }

        #scoreEl {
            font-family: 'JetBrains Mono', monospace; font-size: 2rem; color: white;
            margin-top: 10px; display: block;
        }

        #start-btn {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 15px 40px; background: var(--gold); color: #000;
            font-family: 'Inter', sans-serif; font-weight: bold; border: none;
            font-size: 1.2rem; cursor: pointer; border-radius: 30px;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.6);
            z-index: 20;
        }
        
        .nav-link {
            position: absolute; bottom: 20px; color: rgba(255,255,255,0.4); 
            text-decoration: none; font-size: 0.8rem; letter-spacing: 2px;
            z-index: 20;
        }

        canvas { display: block; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>Silicon Defender</h1>
        <span id="scoreEl">0</span>
    </div>

    <button id="start-btn">INITIALIZE SYSTEM</button>
    <a href="index.html" class="nav-link">RETURN TO TERMINAL</a>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.querySelector('canvas');
        const c = canvas.getContext('2d');
        const scoreEl = document.querySelector('#scoreEl');
        const startBtn = document.querySelector('#start-btn');

        // Set Canvas to Full Screen
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // === 1. PLAYER CLASS (The CPU) ===
        class Player {
            constructor() {
                this.velocity = { x: 0, y: 0 };
                this.rotation = 0;
                this.opacity = 1;
                
                const image = new Image();
                // We draw the ship procedurally (using code) instead of loading an image
                // so it works offline perfectly.
                this.width = 30;
                this.height = 30;
                
                this.position = {
                    x: canvas.width / 2,
                    y: canvas.height - 100
                };
            }

            draw() {
                // Save context state
                c.save();
                c.translate(this.position.x, this.position.y);
                
                // Draw Ship (Triangle)
                c.beginPath();
                c.moveTo(0, -this.height/2); // Top tip
                c.lineTo(this.width/2, this.height/2); // Right bottom
                c.lineTo(-this.width/2, this.height/2); // Left bottom
                c.closePath();
                
                c.fillStyle = '#d4af37'; // Gold
                c.shadowBlur = 15;
                c.shadowColor = '#d4af37';
                c.fill();
                
                c.restore();
            }

            update() {
                if(this.position.x < 0) this.position.x = 0;
                if(this.position.x > canvas.width) this.position.x = canvas.width;
                this.draw();
            }
        }

        // === 2. PROJECTILE CLASS (Data Packets) ===
        class Projectile {
            constructor({ position, velocity }) {
                this.position = position;
                this.velocity = velocity;
                this.radius = 4;
            }

            draw() {
                c.beginPath();
                c.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                c.fillStyle = '#00e5ff'; // Cyan Laser
                c.shadowBlur = 10;
                c.shadowColor = '#00e5ff';
                c.fill();
                c.closePath();
            }

            update() {
                this.draw();
                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;
            }
        }

        // === 3. PARTICLE CLASS (Explosions) ===
        class Particle {
            constructor({ position, velocity, radius, color }) {
                this.position = position;
                this.velocity = velocity;
                this.radius = radius;
                this.color = color;
                this.opacity = 1;
            }

            draw() {
                c.save();
                c.globalAlpha = this.opacity;
                c.beginPath();
                c.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                c.fillStyle = this.color;
                c.fill();
                c.restore();
            }

            update() {
                this.draw();
                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;
                this.opacity -= 0.02; // Fade out
            }
        }

        // === 4. ENEMY CLASS (Glitches/Viruses) ===
        class Enemy {
            constructor() {
                this.velocity = {
                    x: 0,
                    y: (Math.random() * 2) + 1 // Random speed
                };
                
                const randomX = Math.random() * canvas.width;
                this.position = { x: randomX, y: -30 };
                this.width = 30;
                this.height = 30;
                // Randomly choose Red (Virus) or Purple (Bug)
                this.color = Math.random() > 0.5 ? '#ff1744' : '#d500f9';
            }

            draw() {
                c.fillStyle = this.color;
                c.shadowBlur = 10;
                c.shadowColor = this.color;
                c.fillRect(this.position.x, this.position.y, this.width, this.height);
                c.shadowBlur = 0;
            }

            update() {
                this.draw();
                this.position.y += this.velocity.y;
            }
        }

        // === GAME STATE VARIABLES ===
        let player = new Player();
        let projectiles = [];
        let enemies = [];
        let particles = [];
        let animationId;
        let score = 0;
        let frames = 0;
        let gameActive = false;

        function init() {
            player = new Player();
            projectiles = [];
            enemies = [];
            particles = [];
            score = 0;
            frames = 0;
            scoreEl.innerHTML = score;
            gameActive = true;
        }

        // === GAME LOOP ===
        function animate() {
            if (!gameActive) return;

            animationId = requestAnimationFrame(animate);
            c.fillStyle = 'rgba(15, 5, 8, 0.3)'; // Creates trailing effect
            c.fillRect(0, 0, canvas.width, canvas.height);
            
            player.update();
            
            // Clean up particles
            particles.forEach((particle, index) => {
                if(particle.opacity <= 0) {
                    particles.splice(index, 1);
                } else {
                    particle.update();
                }
            });

            // Clean up projectiles
            projectiles.forEach((projectile, index) => {
                if (projectile.position.y + projectile.radius <= 0) {
                    projectiles.splice(index, 1);
                } else {
                    projectile.update();
                }
            });

            // Handle Enemies
            enemies.forEach((enemy, index) => {
                enemy.update();

                // Game Over: Enemy hits player or bottom
                if (enemy.position.y > canvas.height - 50) {
                     cancelAnimationFrame(animationId);
                     gameActive = false;
                     startBtn.style.display = 'block';
                     startBtn.innerHTML = "SYSTEM CRASHED. <br> REBOOT?";
                }

                // Collision: Projectile hits Enemy
                projectiles.forEach((projectile, pIndex) => {
                    // Simple box collision
                    if (
                        projectile.position.y - projectile.radius <= enemy.position.y + enemy.height &&
                        projectile.position.x + projectile.radius >= enemy.position.x &&
                        projectile.position.x - projectile.radius <= enemy.position.x + enemy.width &&
                        projectile.position.y + projectile.radius >= enemy.position.y
                    ) {
                        // Create explosions
                        for(let i=0; i < 10; i++) {
                            particles.push(new Particle({
                                position: {
                                    x: enemy.position.x + enemy.width/2,
                                    y: enemy.position.y + enemy.height/2
                                },
                                velocity: {
                                    x: (Math.random() - 0.5) * 4,
                                    y: (Math.random() - 0.5) * 4
                                },
                                radius: Math.random() * 3,
                                color: enemy.color
                            }));
                        }

                        setTimeout(() => {
                            enemies.splice(index, 1);
                            projectiles.splice(pIndex, 1);
                            score += 100;
                            scoreEl.innerHTML = score;
                        }, 0);
                    }
                });
            });

            // Spawn enemies
            if (frames % 60 === 0) {
                enemies.push(new Enemy());
            }

            frames++;
        }

        // === INPUT CONTROLS ===
        
        // Touch / Mouse Movement
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Stop scrolling
            let touchX = e.touches[0].clientX;
            player.position.x = touchX;
        }, { passive: false });

        canvas.addEventListener('mousemove', (e) => {
            player.position.x = e.clientX;
        });

        // Shooting (Tap or Click)
        window.addEventListener('click', () => {
            if (!gameActive) return;
            projectiles.push(new Projectile({
                position: {
                    x: player.position.x,
                    y: player.position.y
                },
                velocity: {
                    x: 0,
                    y: -10 // Bullet speed up
                }
            }));
        });

        // Also shoot on tap
        window.addEventListener('touchstart', () => {
            if (!gameActive) return;
            projectiles.push(new Projectile({
                position: {
                    x: player.position.x,
                    y: player.position.y
                },
                velocity: {
                    x: 0,
                    y: -10 
                }
            }));
        });

        // Start Game
        startBtn.addEventListener('click', () => {
            init();
            animate();
            startBtn.style.display = 'none';
        });

    </script>
</body>
</html>
